import Mathlib
/-!
# Инструкция по выполнению ДЗ №3.
Вам предлагается заменить `sorry` на валидные доказательства в примерах ниже.
На полный балл достаточно решить **любые 2 задачи**.

Могут оказаться полезными:
* Тактика `ext` для для применения правил экстенсиональности (для множеств, функций, ...)
* Тактика `unfold` для распаковки определений
* Если цель имеет вид `A ⊆ B` можно сразу использовать `intro x hx` где `hx : x ∈ A` и переходить к цели `x ∈ B`
* Точно так же если есть гипотеза `h : A ⊆ B` то можно использовать ее для `apply`: к примеру если `h_mem : x ∈ A`
  то `apply h at h_mem` заменит ее на `h_mem : x ∈ B`.
* Если Вам нужен некоторый вспомогательный факт `Some_New_Fact` и вы чувствуете что он
  должен выводиться из текущего контекста при помощи лемм из библиотеки можно использовать
  синтаксис `have h_new : Some_New_Fact := by exact?`
* `rw [← h]` для переписывания цели/гипотезы при помощи `h` используя `h` в обратном направлении (справа налево)
* `simp` для упрощения выражений.

## Небольшая справка о `simp`
`simp` работает как `rw`, но кроме переданных ему лемм (которых вообще может не быть) он использует леммы
вида `A = B` или `A ↔ B` из библиотеки помеченные аттрибутом `@[simp]`. Если какое-то подвыражение текущей цели
совпадает с левой частью в лемме, то она заменяется на правую часть. Цель тактики `simp` -- привести
выражение к "нормальной форме" насколько это возможно. Например есть `simp`-леммы
в которых доказано `|1| = 1`, `p ∧ True ↔ p`, `List.length List.nil = 0`, `x ∈ {y | P y} ↔ P x` и т.п.
Применяя `simp` к выражениям содержащим левые части этих лемм, мы упрощаем эти выражения и с ними становится
легче работать.

Подробнее можно прочитать в секциях Rewriting и Using the Simplifier здесь:
https://leanprover.github.io/theorem_proving_in_lean4/tactics.html

Не стесняйтесь задавать вопросы в чате!
-/

/-- Задача 1.

Комментарий: эта задача решается в одну строчку тактикой `tauto_set`.
Вам нужно справиться без нее, хотя тактика `tauto` не заперещена.
-/
example {X : Type} (A B C : Set X) (h : A ∪ B ⊆ C) : Cᶜ ⊆ Aᶜ ∩ Bᶜ := by
  sorry

/-- Задача 2. -/
example : ∃ f : ℕ → ℕ × ℕ, f '' {n | Even n} = {(n, m) | n = m} := by
  sorry

def IsLinear (f : ℚ → ℚ) : Prop := ∃ c, ∀ x, f x = c * x

/-- Задача 3. -/
example : {f : ℚ → ℚ | IsLinear f ∧ ∀ x, |f x| = |x|} = {id, -id} := by
  sorry
